= OpenAPI

The Mobile force that fuels the Digital Economy led to the necessity for businesses to establish an omni-channel approach to development in order to optimize costs, increase efficiencies and improve customer experience. An enabler to this approach was APIs, which led to the API Economy and concepts such as API-led or API-first development practices. In addition, microservices architecture has become the architecture of choice for modern development and API-based, i.e. RESTful, communication among microservices has been adopted as the de-facto standard because they are a good fit for the "smart endpoints and dumb pipes",   "decentralized governance" and "decentralized data management" characteristics of microservices. However, as the number of microservices increases in a microservices architecture, their management can become unwieldy. Microservices can be managed via their APIs. Management, security, load balancing, and throttling are policies that can be applied to APIs fronting microservices. MicroProfile OpenAPI provides a set of Java interfaces and programming models which allow Java developers to natively produce OpenAPI v3 documents from their JAX-RS applications.

A fully processed OpenAPI document must be available at the root URL /openapi, as a HTTP GET operation.

.For example:
[source,bash]
----
GET http://myHost:myPort/openapi
----

The protocol required is http. Vendors are encouraged, but not required, to support the https protocol as well, to enable a secure connection to the OpenAPI endpoint.

== Configuration

Configuration of various parts of this specification is provided via the MicroProfile Config mechanism.There are various ways to inject these configuration values into an MP OpenAPI framework, including the default ConfigSource as well as custom ConfigSource.
There are many configurable items. Here is a subset of them.  For a complete list, please refer to the MicroProfile OpenAPI Specification document listed later in this chapter.

.Subset of MicroProfile OpenAPI configuration items
[width="80%",cols="1,^2",options="header"]
|=========================================================
|Configuration item |Description

|mp.openapi.scan.disable | Configuration property to disable annotation scanning. Default value is false.

|mp.openapi.servers | Configuration property to specify the list of global servers that provideconnectivity information. For example,mp.openapi.servers=https://xyz.com/v1,https://abc.com/v1

|mp.openapi.servers.path. | Prefix of the configuration property to specify an alternative list of servers to service all operations in a path. For example,mp.openapi.servers.path./airlines/bookings/\{id}=https://xyz.io/v1

|mp.openapi.servers.operation. | Prefix of the configuration property to specify an alternative list of servers to service an operation. Operations that want to specify an alternative list of servers must define an operationId, a unique string used to identify the operation. For example,mp.openapi.servers.operation.getBooking=https://abc.io/v1

|=========================================================

== Generating the OpenAPI document

The MP OpenAPI specification requires the generation of a valid OpenAPI document from pure JAX-RS 2.0 applications. If you are new to OpenAPI can just deploy their existing JAX-RS application into a MP OpenAPI vendor and check out the output from /openapi!

You then has a few choices:

1. Augment those JAX-RS annotations with the OpenAPI Annotations.

2. Take the initial output from /openapi as a starting point to document your APIs via Static OpenAPI files. Static files can also be written before any code, which is an approach often adopted by enterprises to lock-in the contract of the API, i.e. API-first development practice.

3. Use the Programming model to provide a bootstrap (or complete) OpenAPI model tree.

Additionally, a Filter can be used to update the OpenAPI model after it has been built from the previously described documentation mechanisms.

== Annotations

There are many MicroProfile OpenAPI annotations that you can use in your code.  The following is a partial list of them. For a complete list of MicroProfile OpenAPI annotations, please refer to the please to the MicroProfile OpenAPI Specification document listed later in this chapter.

.Subset of MicroProfile OpenAPI annotations
[width="80%",cols="1,^2",options="header"]
|=========================================================
|Annotation |Description

|@APIResponse | Describes a single response from an API operation.

|@APIResponse | Describes a single response from an API oper
|@Content | Provides schema and examples for a particular media type.

|@Operation | Describes an operation or typically a HTTP method against a specific path.

|@Parameter | Describes a single operation parameter.

|@Schema | Allows the definition of input and output data types.

|=========================================================

Some usage examples of the MicroProfile OpenAPI annotations follow:

.Sample 1 - Simple operation description (abbreviated)
[source,bash]
----
@GET
@Path("/findByStatus")
@Operation(summary = "Finds Pets by status",
           description = "Multiple status values can be provided with comma separated strings")
public Response findPetsByStatus(...)
{ ... }
----

.Output for Sample 1
[source,bash]
----
/pet/findByStatus:
  get:
    summary: Finds Pets by status
    description: Multiple status values can be provided with comma separated strings
    operationId: findPetsByStatus
----

.Sample 2 - Operation with different responses (abbreviated)
[source,bash]
----
@GET
@Path("/{username}")
@Operation(summary = "Get user by user name")  @APIResponse(description = "The user",
             content = @Content(mediaType = "application/json",
                                schema = @Schema(implementation = User.class))),
@APIResponse(responseCode = "400", description = "User not found")
public Response getUserByName(
        @Parameter(description = "The name that needs to be fetched. Use user1 for  testing. ", required = true) @PathParam("username") String username)
{...}
----

.Output for Sample 2
[source,bash]
----
/user/{username}:
    get:
       summary: Get user by user name
       operationId: getUserByName
       parameters:
       - name: username
         in: path
         description: 'The name that needs to be fetched. Use user1 for testing. '
         required: true
         schema:
           type: string
       responses:
         default:
           description: The user
           content:
             application/json:
               schema:
                 $ref: '#/components/schemas/User'
         400:
           description: User not found
----

== Static OpenAPI Files

You can include a pre-generated OpenAPI document that was written, separately from the code, using an open source editor, like link:https://editor.swagger.io[Swagger Editor]. Static files, written before any code, is an approach often adopted by enterprises to lock-in the contract of the API, i.e. API-first development practice.

NOTE: If a document is fully complete then set the mp.openapi.scan.disable configuration property to true. If a document is partially complete, then you will need to augment the OpenAPI snippet with annotations, programming model, or via the filter.

Vendors are required to fetch a single document named openapi with an extension of yml, yaml or json, inside the application moduleâ€™s (i.e. WAR artifact) META-INF folder.

== Programming model

You are able to provide OpenAPI elements via Java POJOs. The complete set of models are found in the link:https://github.com/eclipse/microprofile-open-api/tree/master/api/src/main/java/org/eclipse/microprofile/openapi/models[org.eclipse.microprofile.openapi.models] package.

The OASFactory is used to create all of the elements of an OpenAPI tree.

.For example,
[source,bash]
----
OASFactory.createObject(Info.class).title("Airlines").description("Airlines APIs")  .version("1.0.0");
----

The OASModelReader interface allows you to bootstrap the OpenAPI model tree used by the processing framework. To use it, simply create an implementation of this interface and register it using the mp.openapi.model.reader configuration key.

.Sample META-INF/microprofile-config.properties
[source,bash]
----
mp.openapi.model.reader=com.mypackage.MyModelReader
----

NOTE: Similar to static files, the model reader can be used to provide either complete or partial model trees. If providing a complete OpenAPI model tree, you should set the mp.openapi.scan.disable configuration to true. Oherwise this partial model will be used as the base model during the processing.

== Using a Filter for updates

To update or remove certain elements and fields of the OpenAPI document, you may use a filter. The link:https://github.com/eclipse/microprofile-open-api/blob/master/api/src/main/java/org/eclipse/microprofile/openapi/OASFilter.java[OASFilter] interface allows you to receive callbacks for various key OpenAPI elements. The interface has a default implementation for every method, which allows you to only override the methods you care about. To use it, simply create an implementation of this interface and register it using the mp.openapi.filter configuration key.

.Sample META-INF/microprofile-config.properties
[source,bash]
----
mp.openapi.filter=com.mypackage.MyFilter
----

A registered filter is called once for each filtered element. For example, the method filterPathItem is called for each corresponding PathItem element in the model tree.

== WildFly Swarm extensions

*Eric Wittman - do we have any specific extensions to mention here?*

== Eclipse resources/GitHub coordinates for MicroProfile OpenAPI
The MicroProfile OpenAPI project can be found at following location:

link:https://github.com/eclipse/microprofile-open-api[https://github.com/eclipse/microprofile-open-api]
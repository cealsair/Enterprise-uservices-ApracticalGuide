= OpenAPI

The Mobile force that fuels the Digital Economy led to the necessity for businesses to establish an omni-channel approach to development in order to optimize costs, increase efficiencies, and improve customer experience. An enabler to this approach was APIs, which led to the API Economy and concepts such as API-led or API-first development practices. In addition, microservices architecture has become the architecture of choice for modern development.  API-based (that is, RESTful) communication among microservices has been adopted as the de-facto standard because it is a good fit for the "_smart endpoints and dumb pipes_", "_decentralized governance_" and "_decentralized data management_" characteristics of microservices. However, as the number of microservices increases in a microservices architecture, their management can become unwieldy.  But you can manage your microservices via their APIs.  You can apply management, security, load balancing, and throttling policies to the APIs that are fronting your microservices.

MicroProfile OpenAPI provides a set of Java interfaces and programming models which allow Java developers to natively produce OpenAPI v3 documents from their Java API for RESTful Web Services (JAX-RS) applications.  The specification requires that a fully processed OpenAPI document must be available at the root URL /openapi, as a HTTP GET operation.

.For example:
[source,bash]
----
GET http://myHost:myPort/openapi
----

*****

The protocol required is http. Vendors are encouraged, but not required, to support the https protocol as well, to enable a secure connection to the OpenAPI endpoint.
*****

There are three sources from which the OpenAPI document is created.  These three sources (described in further detail below) are:

1. Generated by processing the JAX-RS annotations (and optional OpenAPI annotations) found in the application.
2. Programmatically built by an application-provided Java class that implements `OasModelReader`.
3. A static OpenAPI document included in the application deployment.

These three sources (any combination) are combined to produce a single OpenAPI document which can be filtered (by providing a Java class that implements the `OasFilter` interface) and then served at the above `/openapi` endpoint.

== Configuration

Configuration of various parts of this specification is provided via the MicroProfile Config mechanism.
There are various ways to inject these configuration values into a MicroPrpfile OpenAPI framework, including the default ConfigSource as well as custom ConfigSources.
There are many configurable items, the following table contains a subset of them. 

.Subset of MicroProfile OpenAPI configuration items
[width="80%",cols="1,^2",options="header"]
|=========================================================
|Configuration item |Description

|mp.openapi.scan.di
sable | Configuration property to disable annotation scanning. Default value is "false".

|mp.openapi.servers | Configuration property to specify the list of global servers that provide
connectivity information. For example,
mp.openapi.servers=https://xyz.com/v1,https://abc.com/v1

|mp.openapi.servers
.path. | Prefix of the configuration property to specify an alternative list of servers to
 service all operations in a path. For example,
mp.openapi.servers.path./airlines/bookings/\{id}=https://xyz.io/v1

|mp.openapi.servers
.operation. | Prefix of the configuration property to specify an alternative list of servers to service an operation. Operations that want to specify an alternative list of servers must define an operationId, a unique string used to identify the
 operation. For example,
mp.openapi.servers.operation.getBooking=https://abc.io/v1

|=========================================================

 For a complete list of confuration items, please refer to the MicroProfile OpenAPI Specification document listed later in this chapter.


== Generating the OpenAPI document

As already described, the MicroProfile OpenAPI specification requires that an OpenAPI document be generated from a combination of three sources (and then filtered).

You then have a few choices:


1. Augment the JAX-RS annotations with the OpenAPI Annotations.


2. Take the initial output from `/openapi` as a starting point to document your APIs via Static OpenAPI files. Static files can also be written before any code, which is an approach often adopted by enterprises to lock-in the contract of the API, that is, API-first development practice.


3. Use the Programming model to provide a bootstrap (or complete) OpenAPI model tree.

Additionally, a filter can be used to update the OpenAPI model after it has been built from 
the previously described documentation mechanisms.

== Annotations

Probably the most common source of OpenAPI information is the set annotations that make up the definition of a standard JAX-RS application.  These annotations, along with additional (optional) annotations defined by the MicroProfile OpenAPI specification, can be scanned and processed by the MicroProfile platform to produce an OpenAPI document.

NOTE: The MP OpenAPI specification requires the generation of a valid OpenAPI document from pure JAX-RS 2.0 applications. If you are new to OpenAPI, you can just deploy your existing JAX-RS application into a MicroProfile OpenAPI runtime and check out the output from `/openapi`.

In order to fill out additional details of the generated OpenAPI document, you may further annotate your JAX-RS application with the many annotations defined by the MicroProfile OpenAPI specification.  The following table contains a partial list of these additional annotations.  

.Subset of MicroProfile OpenAPI annotations
[width="80%",cols="1,^2",options="header"]
|=========================================================
|Annotation |Description

|@APIResponse | Describes a single response from an API operation.

|@Content | Provides schema and examples for a particular media type.

|@Operation | Describes an operation or typically a HTTP method against a specific path.

|@Parameter | Describes a single parameter of an operation.

|@Schema | Allows the definition of input and output data types.

|=========================================================

For a complete list of annotations, please refer to the MicroProfile OpenAPI Specification document listed later in this chapter.

Some usage examples of the MicroProfile OpenAPI annotations follow:

.Sample 1 - Simple operation description (abbreviated)
[source,bash]
----
@GET
@Path("/findByStatus")
@Operation(summary = "Finds Pets by status",
           description = "Multiple status values can be provided with comma separated
 strings")
public Response findPetsByStatus(...)
{ ... }
----

.Output for Sample 1
[source,bash]
----
/pet/findByStatus:
  get:
    summary: Finds Pets by status
    description: Multiple status values can be provided with comma separated strings
    operationId: findPetsByStatus
----

.Sample 2 - Operation with different responses (abbreviated)
[source,bash]
----
@GET
@Path("/{username}")
@Operation(summary = "Get user by user name")
  @APIResponse(description = "The user",
             content = @Content(mediaType = "application/json",
                                schema = @Schema(implementation = User.class))),
@APIResponse(responseCode = "400", description = "User not found")
public Response getUserByName(
        @Parameter(description = "The name that needs to be fetched. Use user1 for
  testing. ", required = true) @PathParam("username") String username)

{...}
----

.Output for Sample 2
[source,bash]
----
/user/{username}:
    get:
       summary: Get user by user name
       operationId: getUserByName
       parameters:
       - name: username
         in: path
         description: 'The name that needs to be fetched. Use user1 for testing. '
         required: true
         schema:
           type: string
       responses:
         default:
           description: The user
           content:
             application/json:
               schema:
                 $ref: '#/components/schemas/User'
         400:
           description: User not found
----

== Static OpenAPI Files

You can include a pre-generated OpenAPI document that was written, separately from the code, using an open source editor, like link:https://editor.swagger.io[Swagger Editor]. Static files, written before any code, is an approach often adopted by enterprises to lock-in the contract of the API, that is, API-first development practice.

NOTE: If a document is fully complete then set the *mp.openapi.scan.disable* configuration property to *true*. If a document is partially complete, then you will need to augment the OpenAPI snippet with annotations or the programming model.

Vendors are required to fetch a single document named openapi with an extension of `yml`, `yaml` or `json`, inside the application moduleâ€™s (that is, the WAR artifact) META-INF folder.

== Programming model

You are able to provide OpenAPI elements via Java POJOs (Plain Old Java Objects).  The complete set of models are found in the link:https://github.com/eclipse/microprofile-open-api/tree/master/api/src/main/java/org/eclipse/microprofile/openapi/models[org.eclipse.microprofile.openapi.models] package.

The `OASFactory` is used to create all of the elements of an OpenAPI tree.

.For example,
[source,bash]
----
OASFactory.createObject(Info.class).title("Airlines")
          .description("Airlines APIs").version("1.0.0");
----

The `OASModelReader` interface allows you to bootstrap the OpenAPI model tree used by the processing framework. To use it, simply create an implementation of this interface and register it using the `mp.openapi.model.reader` configuration key.

.Sample META-INF/microprofile-config.properties
[source,bash]
----
mp.openapi.model.reader=com.mypackage.MyModelReader
----

NOTE: Similar to static files, the model reader can be used to provide either complete or partial model trees. If providing a complete OpenAPI model tree, you should set the `mp.openapi.scan.disable` configuration to "true". Otherwise this partial model will be used as the base model during the processing.

== Using a Filter for updates

To remove certain elements and fields of the OpenAPI document, you may use a filter. The link:https://github.com/eclipse/microprofile-open-api/blob/master/api/src/main/java/org/eclipse/microprofile/openapi/OASFilter.java[OASFilter] interface allows you to receive callbacks for various key OpenAPI elements. The interface has a default implementation for every method, which allows you to only override the methods you care about. To use it, simply create an implementation of this interface and register it using the `mp.openapi.filter` configuration key.

.Sample META-INF/microprofile-config.properties
[source,bash]
----
mp.openapi.filter=com.mypackage.MyFilter
----

A registered filter is called once for each model element. For example, the method `filterPathItem` is called for each corresponding `PathItem` element in the model tree.

== WildFly Swarm extensions

There are currently no WildFly Swarm specific extensions available for use with MicroProfile OpenAPI.

== Eclipse resources/GitHub coordinates for MicroProfile OpenAPI
The MicroProfile OpenAPI project can be found at following location:

link:https://github.com/eclipse/microprofile-open-api[https://github.com/eclipse/microprofile-open-api]
